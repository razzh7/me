---
title: Ant-Design-Icons çš„ç”Ÿæˆä¹‹æ—…(ä¸Š)
date: 2023-10-25
tech: blog
---

## èƒŒæ™¯

â€‹	æœ€è¿‘ä¸€ç›´åœ¨æ£é¼“ç»„ä»¶åº“çš„äº‹æƒ…ï¼Œé¦–å…ˆè¦è§£å†³çš„éš¾é¢˜æ˜¯ `Icons` çš„é—®é¢˜ï¼Œå› ä¸ºç»„ä»¶åº“ä¸­æ¯ä¸ªç»„ä»¶åŸºæœ¬éƒ½ç”¨å¾—åˆ° Icon ç»„ä»¶ï¼Œäºæ˜¯æ‰¾åˆ°äº† [Ant-Design-Icons](https://github.com/ant-design/ant-design-icons)ï¼Œå®ƒçš„ä¸»è¦åŸç†æ˜¯å°† `SVG` æ–‡ä»¶è½¬æ¢æˆ `AST` æŠ½è±¡èŠ‚ç‚¹ï¼Œå†åˆ†å‘ç»™å„ä¸ªæ¡†æ¶æ¸²æŸ“ã€‚

## ä¸ºä»€ä¹ˆéœ€è¦ SVG to AST
å°† SVG æŠ½è±¡æˆ AST æŠ½è±¡èŠ‚ç‚¹ä¸»è¦æ˜¯ä¸ºäº†é€‚é…å„ä¸ªæ¡†æ¶çš„éœ€è¦ï¼Œæ¯”å¦‚ `React` å¯ä»¥ä½¿ç”¨ `createElement` å‡½æ•°æ¸²æŸ“æŠ½è±¡èŠ‚ç‚¹ï¼Œ`Vue` å¯ä»¥ä½¿ç”¨ `h` å‡½æ•°æ¥æ¸²æŸ“æŠ½è±¡èŠ‚ç‚¹

## æ¢ç´¢

â€‹	`Ant-Design-Icons4.x` æ˜¯ä¸€ä¸ª Lerna + TS ç®¡ç†çš„å¤šåŒ…ä»“åº“ï¼Œé‡Œé¢é›†æˆäº†å„ä¸ªæ¡†æ¶çš„ Icons ç»„ä»¶åŒ…ï¼Œæˆ‘ä»¬ä»Šå¤©çš„ä¸»è§’ icons-svgï¼Œæ˜¯ä¸“é—¨ç”¨æ¥è§£æ SVG å›¾æ ‡æ–‡ä»¶ï¼Œå¹¶å°†å…¶æŠ½è±¡ä¸º AST æŠ½è±¡èŠ‚ç‚¹æ ‘ï¼Œå°±åƒè¿™æ ·ï¼š

```ts
// This icon file is generated automatically.

import { IconDefinition } from '../types';

const AppstoreTwoTone: IconDefinition = {
  "icon": function render(primaryColor, secondaryColor) { 
    return {
      "tag":"svg",
      "attrs": {
        "viewBox":"64 64 896 896",
        "focusable":"false"
      },
      "children": [
        {
          "tag":"path",
          "attrs": {
            "d":"...",
            "fill":primaryColor
          }
        },
        {
          "tag":"path",
          "attrs": {
            "d":"...",
            "fill":secondaryColor
          }
        }
      ]
    }; 
  },
  "name":"appstore",
  "theme":"twotone"
};

export default AppstoreTwoTone;
```

  å®ƒå°† SVG è§£ææˆäº†ä¸€ä¸ªæŠ½è±¡èŠ‚ç‚¹ `AST` ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥é€šè¿‡å®‰è£…è¿™ä¸ªåŒ…æ¥å¯¼å…¥è¿™ä¸ªæ–‡ä»¶ï¼Œç”Ÿæˆå¯¹åº”çš„ `ReactElement` æˆ– `VNode`ï¼Œè¿™æ ·ä¸€ä¸ªå†…ç½® Icon ç»„ä»¶å°±å®Œæˆäº†

â€‹  æ‰“å¼€ package.jsonï¼Œç›´å¥” script å­—æ®µï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä¸¤è¡Œå‘½ä»¤ï¼Œæ˜¯è·Ÿç”Ÿæˆä¸Šè¿°çš„ AST æ–‡ä»¶ç›¸å…³çš„ã€‚

```json
"scripts": {
   "g": "npm run generate",
   "generate": "cross-env NODE_ENV=production gulp --require ts-node/register/transpile-only",
}
```

  å¯ä»¥çœ‹åˆ°æåˆ°äº† gulp å‘½ä»¤ï¼Œå®ƒæ˜¯æ‰§è¡Œç›®å½•ä¸‹çš„ [gulpfile.ts](https://github.com/ant-design/ant-design-icons/blob/master/packages/icons-svg/gulpfile.ts) æ–‡ä»¶çš„å‘½ä»¤ï¼Œæ‰€ä»¥ç”Ÿæˆæ–‡ä»¶çš„å…¥å£å°±åœ¨è¿™ä¸ªæ–‡ä»¶ä¸­ï¼Œæˆ‘åªæˆªå–äº†ä¸€éƒ¨åˆ†ä»£ç 

```ts
export const generateIcons = ({
  from,
  toDir,
  svgoConfig,
  theme,
  extraNodeTransformFactories,
  stringify,
  template,
  mapToInterpolate,
  filename
}: GenerateIconsOptions) =>
  function GenerateIcons() {
    return src(from)
      .pipe(svgo(svgoConfig))
      .pipe(
        svg2Definition({
          theme,
          extraNodeTransformFactories,
          stringify
        })
      )
      .pipe(useTemplate({ template, mapToInterpolate }))
      .pipe(
        rename((file) => {
          if (file.basename) {
            file.basename = filename({ name: file.basename });
            file.extname = '.ts';
          }
        })
      )
      .pipe(dest(toDir));
  };
```

  è¿™ä¸ªå‡½æ•°ä¸»è¦æ˜¯é€šè¿‡ gulp å°†ä¸€ç³»åˆ—çš„ä»»åŠ¡ç»„è£…åœ¨ä¸€èµ·ï¼Œé¦–å…ˆå®ƒä½¿ç”¨ `SVGO` è¿™ä¸ªåº“æ¥ä¼˜åŒ–ä¸€ä¸‹ SVG å›¾æ ‡çš„ä½“ç§¯ï¼Œsvgo å¯ä»¥å°†ä¸éœ€è¦çš„SVGå±æ€§ç»™å‰”é™¤ï¼Œå°† SVG æ–‡ä»¶è¿›è¡Œç˜¦èº«æ“ä½œã€‚

â€‹  ä¸‹ä¸€æ­¥å°±æ˜¯å°† SVG è½¬æ¢æˆæŠ½è±¡èŠ‚ç‚¹æ ‘çš„è¿‡ç¨‹äº†ï¼Œä¹Ÿæ˜¯ç”Ÿæˆ Icons çš„æ ¸å¿ƒæ–¹æ³•ï¼Œå®ƒåœ¨ plugins/svg2Definition/index.ts æ–‡ä»¶ä¸­è¢«å¯¼å‡ºï¼š

```ts
import { createTrasformStream } from '../creator';
import { ThemeType, AbstractNode } from '../../templates/types';
import {
  pipe,
  clone,
  map,
  filter,
  where,
  equals,
  gt as greaterThan,
  both,
  unless,
  length,
  dissoc as deleteProp,
  reduce,
  path as get,
  __,
  applyTo,
  defaultTo,
  objOf,
  assoc
} from 'ramda';
import parseXML, { Element } from '@rgrove/parse-xml';
// SVG => IconDefinition
export const svg2Definition = ({
  theme,
  extraNodeTransformFactories,
  stringify
}: SVG2DefinitionOptions) =>
  createTrasformStream((SVGString, { stem: name }) =>
    applyTo(SVGString)(
      pipe(
        // 0. The SVG string is like that:
        // <svg viewBox="0 0 1024 1024"><path d="..."/></svg>

        parseXML,

        // 1. The parsed XML root node is with the JSON shape:
        // {
        //   "type": "document",
        //   "children": [
        //     {
        //       "type": "element",
        //       "name": "svg",
        //       "attributes": { "viewBox": "0 0 1024 1024" },
        //       "children": [
        //         {
        //           "type": "element",
        //           "name": "path",
        //           "attributes": {
        //             "d": "..."
        //           },
        //           "children": []
        //         }
        //       ]
        //     }
        //   ]
        // }

        pipe(
          // @todo: "defaultTo" is not the best way to deal with the type Maybe<Element>
          get<Element>(['children', 0]),
          defaultTo(({} as any) as Element)
        ),

        // 2. The element node is with the JSON shape:
        // {
        //   "type": "element",
        //   "name": "svg",
        //   "attributes": { "viewBox": "0 0 1024 1024" },
        //   "children": [
        //     {
        //       "type": "element",
        //       "name": "path",
        //       "attributes": {
        //         "d": "..."
        //       },
        //       "children": []
        //     }
        //   ]
        // }

        element2AbstractNode({
          name,
          theme,
          extraNodeTransformFactories
        }),

        // 3. The abstract node is with the JSON shape:
        // {
        //   "tag": "svg",
        //   "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" },
        //   "children": [
        //     {
        //       "tag": "path",
        //       "attrs": {
        //         "d": "..."
        //       }
        //     }
        //   ]
        // }

        pipe(objOf('icon'), assoc('name', name), assoc('theme', theme)),
        defaultTo(JSON.stringify)(stringify)
      )
    )
  );
```

â€‹  ä½œè€…ä½¿ç”¨äº† `ramda`ï¼Œæœ‰åçš„å‡½æ•°å¼ç¼–ç¨‹çš„åº“ï¼Œå¯¹äºä¹ æƒ¯äº†å†™å‘½ä»¤å¼ç¼–ç¨‹çš„æˆ‘ï¼Œçœ‹åˆ°è¿™æ ·çš„å‡½æ•°å¼èŒƒå¼ç¼–å†™çš„ä»£ç ï¼Œå½“æ—¶çš„æƒ³æ³•æ˜¯ä¸ºä»€ä¹ˆä¸ä½¿ç”¨å‘½ä»¤å¼çš„ç¼–ç¨‹å‘¢ï¼Ÿæ„Ÿè§‰é‚£æ ·å¥½è°ƒè¯•ä¹Ÿæ›´ç›´è§‚ä¸€äº›ï¼Œå…¶å®æœ‰ç‚¹æœ›è€Œå´æ­¥çš„æ„Ÿè§‰ğŸ˜µâ€ğŸ’«

  æ—¢ç„¶çœ‹åˆ°è¿™é‡Œäº†ï¼Œè¿˜æ˜¯è¦ç»§ç»­çœ‹ä¸‹å»å§ï¼Ÿä»”ç»†ä¸€ä¸‹è¿™ä¸ªæ–¹æ³•ä½œè€…è´´å¿ƒçš„æ·»åŠ äº†ä»£ç çš„æ³¨é‡Šï¼Œç»™é˜…è¯»ä»£ç çš„äººå±•ç¤ºäº† SVG æ˜¯å¦‚ä½•è¢«è½¬æ¢æˆ AST çš„è¿‡ç¨‹ã€‚

â€‹  é¦–å…ˆæ‰§è¡Œäº† `createTrasformStream` æ–¹æ³•ï¼Œå°†æˆ‘ä»¬è¦æ‰§è¡Œçš„å‡½æ•°ä¼ å…¥ï¼Œ`createTrasformStream` æœ¬èº«æ˜¯ä¸ºäº†æ»¡è¶³ gulp çš„ `pipe` ç®¡é“æ–¹æ³•çš„å…¥å‚è€Œå°è£…çš„ä¸€ä¸ªæ–¹æ³•ï¼Œå…¶å†…éƒ¨ä½¿ç”¨äº†é—­åŒ…å’Œ `through2` åŒ…è£…äº†ä¸€ä¸ªè½¬æ¢æµ(Transform)ï¼š

```ts
import through from 'through2';
import File from 'vinyl';

export const createTrasformStream = (fn: (raw: string, file: File) => string) =>
  through.obj((file: File, encoding, done) => {
    if (file.isBuffer()) {
      const before = file.contents.toString(encoding);
      try {
        const after = fn(before, file);
        file.contents = Buffer.from(after);
        done(null, file);
      } catch (err) {
        done(err, null);
      }
    } else {
      done(null, file);
    }
  });
```
  å…¶ä¸­ï¼Œ`through.obj` ä¸­çš„å›è°ƒ `file` å‚æ•°å°±æ˜¯ç»è¿‡ SVGO ä¼˜åŒ–åçš„ SVG å­—ç¬¦ä¸²ï¼Œä¹‹åé€šè¿‡é—­åŒ…æ‹¿åˆ°æˆ‘ä»¬ä¼ å…¥ createTrasformStream çš„å›è°ƒå‡½æ•°æ‰§è¡Œã€‚  

â€‹  å›åˆ°pipeä¸­ï¼Œä½¿ç”¨ applyTo æ–¹æ³•å°† SVGString ç»‘å®šï¼Œå¯ä»¥è®© pipe ä¸­çš„æ–¹æ³•ä¼šè¢«è‡ªåŠ¨ä¼ å…¥ SVGString å‚æ•°ï¼Œè€Œ pipe ä¸­ç»„è£…çš„æ–¹æ³•çš„æ‰§è¡Œç»“æœä¼šä¼ é€’ç»™ä¸‹ä¸€ä¸ªå‡½æ•°çš„å½¢å‚ä¸­ï¼Œæ­£å¦‚ä½œè€…æ³¨é‡Šä¸­å†™åˆ°çš„ä»0 -> 1çš„è¿‡ç¨‹ï¼Œä½¿ç”¨ `parseXML` åº“å°† SVGString æŠ½è±¡æˆä¸€ä¸ª Node èŠ‚ç‚¹æ ‘ï¼š

```ts
  {
    "type": "document",
    "children": [
      {
        "type": "element",
        "name": "svg",
        "attributes": { "viewBox": "0 0 1024 1024" },
        "children": [
          {
            "type": "element",
            "name": "path",
            "attributes": {
              "d": "..."
            },
            "children": []
          }
        ]
      }
    ]
  }
```
â€‹  ä½†è¿™ä¸æ˜¯æˆ‘ä»¬æƒ³è¦çš„ç»“æœï¼Œæ‰€ä»¥ä½œè€…ä½¿ç”¨äº† ramda ä¸­çš„ `get` æ–¹æ³•æ‹¿åˆ° `children` æ•°ç»„ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå¹¶ä½¿ç”¨`defaultTo` æ–¹æ³•æ¥é™åˆ¶ä¸€ä¸‹å¦‚æœ `children` æ˜¯ä¸€ä¸ªç©ºæ•°ç»„çš„æ—¶å€™ï¼Œé‚£ä¹ˆå°±å°†å®ƒçš„ç¬¬ä¸€ä¸ªå…ƒç´ è®¾ç½®æˆä¸€ä¸ªå¯¹è±¡ï¼Œæ¥è§„é¿æŠ¥é”™ã€‚

â€‹  æ¥ä¸‹æ¥çš„ `element2AbstractNode` æ–¹æ³•ï¼Œä¹Ÿæ˜¯åœ¨è¿™ä¸ªæ–‡ä»¶ä¸­ï¼š

```ts
function element2AbstractNode({
  name,
  theme,
  extraNodeTransformFactories
}: XML2AbstractNodeOptions) {
  return ({ name: tag, attributes, children }: Element): AbstractNode =>
  {
    return applyTo(extraNodeTransformFactories)(
      pipe(
        // factory -> (option) => (asn) => asn
        map((factory: TransformFactory) => factory({ name, theme })),
        // [(asn) => {}, (asn) => {}]
        reduce(
          (transformedNode, extraTransformFn) =>
            extraTransformFn(transformedNode),
          applyTo({
            tag,
            attrs: clone(attributes),
            children: applyTo(children as Element[])(
              pipe(
                filter<Element, 'array'>(where({ type: equals('element') })),
                map(
                  element2AbstractNode({
                    name,
                    theme,
                    extraNodeTransformFactories
                  })
                )
              )
            )
          })(
            unless<AbstractNode, AbstractNode>(
              where({
                children: both(Array.isArray, pipe(length, greaterThan(__, 0)))
              }),
              deleteProp('children')
            )
          )
        )
      )
    );
  }
}
```

  è¿™ä¸ªå‡½æ•°æ˜¯ä¸€ä¸ªé—­åŒ…å‡½æ•°ï¼Œè¿”å›ä¸€ä¸ªç®­å¤´å‡½æ•°ï¼Œè€Œç®­å¤´å‡½æ•°å¼•ç”¨ç€é—­åŒ…å‡½æ•°çš„å˜é‡ä»¬ `name`, `theme`, `extraNodeTransformFactories`

  ç®­å¤´å‡½æ•°ä¸­è§£æ„äº† parseXML ç”Ÿæˆçš„ AST æ ‘ï¼Œå®é™…ä¸Šï¼Œç®­å¤´å‡½æ•°ä¸­çš„å½¢å‚å°±æ˜¯ä¸Šè¿°æ³¨é‡Šç¬¬2æ­¥çš„ç»“æ„ï¼Œè¯»åˆ°è¿™é‡Œï¼Œæˆ‘å·²ç»æ„Ÿå—åˆ°é—­åŒ…å’Œå‡½æ•°å¼ç¼–ç¨‹çš„é­…åŠ›æ‰€åœ¨äº†ğŸ¤©ã€‚

  æ•´ä¸ªç”Ÿæˆ AST çš„è¿‡ç¨‹å°±åƒæµæ°´çº¿ä¸€æ ·è¢«ç»„è£…èµ·æ¥ï¼Œå†™æ³•æ¯”èµ·å‘½ä»¤å¼çš„ç¼–ç¨‹ä¼˜é›…äº†è®¸å¤šï¼Œè€Œä¸”æ„Ÿè§‰å¾ˆé¡ºæ‰‹ã€‚

  å›å½’åˆ°ä»£ç ä¸­ï¼Œé¦–å…ˆä½¿ç”¨äº† applyTo å¯¹ extraNodeTransformFactories å‚æ•°è¿›è¡Œç»‘å®šï¼Œé‚£ä¹ˆè¿™ä¸ªå‚æ•°æ˜¯ä»€ä¹ˆä¸œä¸œï¼Ÿè¿™ä¸ªå‚æ•°æ˜¯åœ¨æˆ‘ä»¬çš„å…¥å£æ–‡ä»¶ gulpfile.ts ä¸­æ‰§è¡Œ `generateIcons` æ–¹æ³•ä¼ å…¥çš„ï¼Œæ–‡ç« çš„å¼€å¤´æœ‰è´´å‡ºï¼š

```ts
  // 2.2 generate abstract node with the theme "filled"
  generateIcons({
    theme: 'filled',
    from: ['svg/filled/*.svg'],
    toDir: 'src/asn',
    svgoConfig: generalConfig,
    extraNodeTransformFactories: [
      assignAttrsAtTag('svg', { focusable: 'false' }),
      adjustViewBox
    ],
    stringify: JSON.stringify,
    template: iconTemplate,
    mapToInterpolate: ({ name, content }) => ({
      identifier: getIdentifier({ name, themeSuffix: 'Filled' }),
      content
    }),
    filename: ({ name }) => getIdentifier({ name, themeSuffix: 'Filled' })
  })
```

  ä½œè€…åœ¨å…¥å£æ–‡ä»¶ä½¿ç”¨ generateIcons æ–¹æ³•ç”Ÿæˆäº†ä¸‰ä¸ªä¸»é¢˜çš„ Icons AST æ–‡ä»¶ï¼Œè¿™é‡Œåªè´´å‡ºäº†ä¸€éƒ¨åˆ†ï¼Œæœ‰å…´è¶£çš„æœ‹å‹å¯ä»¥å»æºç é‡Œé¢ç¿»ä¸€ç¿»ã€‚

  æˆ‘ä»¬åœ¨ä¸Šé¢å¯ä»¥çœ‹åˆ° `extraNodeTransformFactories` æ•°ç»„ï¼Œé‡Œé¢æ‰§è¡Œäº†`assignAttrsAtTag`ï¼Œå®ƒåœ¨ plugins/svg2Definition/tranforms/creator.ts ä¸­ï¼š

```ts
export function assignAttrsAtTag(
  tag: string,
  extraPropsOrFn:
    | Dictionary
    | ((
        options: TransformOptions & { previousAttrs: Dictionary }
      ) => Dictionary)
): TransformFactory {
  return (options) => (asn) => {
    return when<AbstractNode, AbstractNode>(
      where({
        tag: equals(tag)
      }),
      evolve({
        attrs: pipe<Dictionary, Dictionary, Dictionary>(
          clone,
          mergeLeft(
            typeof extraPropsOrFn === 'function'
              ? extraPropsOrFn(
                  mergeRight(options, { previousAttrs: asn.attrs })
                )
              : extraPropsOrFn
          )
        )
      })
    )(asn)
  };
}
```

  è¿™ä¸ªå‡½æ•°ä¹Ÿæ˜¯è¿”å›ä¸€ä¸ªç®­å¤´å‡½æ•°ï¼Œä¸»è¦çš„ä½œç”¨æ˜¯å¯¹ SVGAST ä¸­çš„ attrs å¯¹è±¡ä¸­çš„å±æ€§è¿›è¡Œæ”¹åŠ¨ï¼Œå›åˆ° `element2AbstractNode` æ–¹æ³•ï¼š

```ts
function element2AbstractNode({
  name,
  theme,
  extraNodeTransformFactories
}: XML2AbstractNodeOptions) {
  return ({ name: tag, attributes, children }: Element): AbstractNode =>
  {
    return applyTo(extraNodeTransformFactories)(
      pipe(
        // factory -> (option) => (asn) => asn
        map((factory: TransformFactory) => factory({ name, theme })),
        // [(asn) => {}, (asn) => {}]
        reduce(
          (transformedNode, extraTransformFn) =>
            extraTransformFn(transformedNode),
          applyTo({
            tag,
            attrs: clone(attributes),
            children: applyTo(children as Element[])(
              pipe(
                filter<Element, 'array'>(where({ type: equals('element') })),
                map(
                  element2AbstractNode({
                    name,
                    theme,
                    extraNodeTransformFactories
                  })
                )
              )
            )
          })(
            unless<AbstractNode, AbstractNode>(
              where({
                children: both(Array.isArray, pipe(length, greaterThan(__, 0)))
              }),
              deleteProp('children')
            )
          )
        )
      )
    );
  }
}
```

  å…¶ä¸­çš„ `map` æ–¹æ³•å°±æ˜¯æ‰§è¡Œäº†åˆ†åˆ« `extraNodeTransformFactories` æ•°ç»„ä¸­çš„æ–¹æ³•ï¼Œ`reduce`æ–¹æ³•æ˜¯å°† applyTo ä¹‹åçš„å€¼ï¼š

```ts
const SVGASt = {
  "tag": "svg",
  "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" },
  "children": [
    {
      "tag": "path",
      "attrs": {
        "d": "..."
      }
    }
  ]
}
```

  ä¼ å…¥ `extraTransformFn` æ–¹æ³•ä¸­æ‰§è¡Œï¼Œè¿™æ ·å°±å¯ä»¥å¯¹ AST çš„ `attrs` å¯¹è±¡è¿›è¡Œé¢å¤–çš„ä¿®æ”¹æ“ä½œï¼Œè¿™æ ·æˆ‘ä»¬å·²ç»å¯ä»¥çœ‹åˆ°ä¸€ä¸ªæ¯”è¾ƒå®Œæ•´çš„ AST ç»“æ„äº†ï¼Œæ¥ç€ä¸‹é¢çš„æ“ä½œï¼š

```ts
pipe(objOf('icon'), assoc('name', name), assoc('theme', theme)),
defaultTo(JSON.stringify)(stringify)
```

  ä½¿ç”¨ `objof` æ–¹æ³•å°† SVGAST æ”¾åˆ°æ–°å¯¹è±¡çš„ icon å±æ€§ä¸­ï¼Œå°†æ–°å¢ nameã€theme å±æ€§ï¼Œæ­¤æ—¶çš„æ•°æ®ç»“æ„å°±å˜æˆäº†è¿™æ ·ï¼š

```ts
const SVGASt = {
  icon: {
    "tag": "svg",
    "attrs": { 
      "viewBox": "0 0 1024 1024", 
      "focusable": "false" 
    },
    "children": [
      {
        "tag": "path",
        "attrs": {
          "d": "..."
        }s
      }
    ]  
  },
  name: "...",
  theme: '...'
}
```

  å·²ç»è·Ÿæ–‡ä¸­è´´å‡ºçš„æ•°æ®ç»“æ„å·²ç»å¾ˆåƒäº†å¯¹å§ï¼Ÿè¿˜å·®æœ€åä¸€æ­¥ï¼Œå¯¹åŒè‰²å›¾æ ‡çš„å¤„ç†ï¼ŒåŒè‰²å›¾æ ‡çš„åŸç†å¯¹å¡«å…… `path` å…ƒç´ ä¸Šçš„ `fill` å±æ€§çš„é¢œè‰²ï¼Œæˆ‘ä»¬è¦åšçš„å°±æ˜¯åœ¨ `path` å…ƒç´ çš„ `fill` ä¸Šæ·»åŠ ä¸Šæˆ‘ä»¬è‡ªå®šä¹‰çš„é¢œè‰²ï¼Œä¸¤ä¸ª `path` å¯¹åº”ä¸¤ä¸ªé¢œè‰²å˜é‡ï¼š`primaryColor` å’Œ `secondaryColor`ã€‚

  ä»£ç ä¸­çš„æœ€åä¸€ä¸ªæ­¥éª¤ `defaultTo(JSON.stringify)(stringify)` å°±æ˜¯åšçš„è¿™ä»¶äº‹ï¼Œåœ¨å…¥å£æ–‡ä»¶ gulpfile.ts ä¸­å¯¹äºåŒè‰²å›¾æ ‡ä½œè€…ä¼šä¼ å…¥ `twotoneStringify` å‡½æ•°ï¼Œè€Œå¯¹äºå•è‰²å›¾æ ‡åˆ™æ˜¯ä¼ å…¥ `JSON.stringify` æ¥å°†å¯¹è±¡è½¬ä¸º JSON å­—ç¬¦ä¸²ï¼š

```ts
{
  "icon": function render(primaryColor, secondaryColor) {
    return {
      "icon": {
        "tag": "svg",
        "attrs": { 
          "viewBox": "0 0 1024 1024", 
          "focusable": "false" 
        },
        "children": [
            {
              "tag": "path",
              "attrs": {
              "d": "..."
              }
            }
          ]
      },
      "name": "...",
      "theme": '...'
    }
  }
}
```

  åˆ°æ­¤ SVG æ–‡ä»¶çš„ AST ä¹‹æ—…ä¹Ÿå°±å®Œæˆäº†ã€‚

  æºç ä¸­åç»­è¿˜æ˜¯ç”Ÿæˆ AST çš„å…¥å£æ–‡ä»¶å’Œå°† SVGAST é‡æ–°è½¬æ¢æˆ SVG æ–‡ä»¶çš„è¿‡ç¨‹ï¼Œæœ¬æ–‡ç¯‡å¹…ä¹Ÿæ˜¯æœ‰ç‚¹é•¿äº†ï¼Œæ”¾åœ¨åé¢å†å†™ä¸€ç¯‡æ–‡ç« è®°å½•ä¸€ä¸‹å§ğŸ˜‚ã€‚

## å†™åœ¨æœ€å
  ä¹‹å‰æ˜¯ä¸€ç›´å¬è¯´å‡½æ•°å¼ç¼–ç¨‹è¿™ä¸ªæ¦‚å¿µçš„ï¼Œä½†è‡ªå·±å´æ²¡æœ‰å®è·µè¿‡ï¼Œè¿™å‡ å¤©çœ‹äº† Ant-Design-Icons çš„æºç åï¼Œæ·±å—æ„Ÿè§¦ï¼Œä»åˆšå¼€å§‹çš„æŠ—æ‹’ï¼Œåˆ°ç°åœ¨è‡ªå·±ä¹Ÿåœ¨æ¥çº³ã€å­¦ä¹ å‡½æ•°å¼ç¼–ç¨‹ï¼Œå­¦ä¹  Ramdaï¼ŒRxjs ç­‰åº“ï¼Œå­¦ä»¥è‡´ç”¨ï¼Œä¹Ÿä¼šåœ¨åé¢çš„ç»„ä»¶åº“ç¼–ç¨‹ä¸­ç”¨ä¸Šã€‚